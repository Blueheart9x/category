diff --git a/properties.js b/properties.js
index 01971db..6895585 100644
--- a/properties.js
+++ b/properties.js
@@ -61,11 +61,18 @@ const defaultPropertySettings = {
   valueStoreProperty: "_state",
 }
 
+export {
+  prepareClassForManagedPropertiesAfterCreation,
+  hasManagedProperties,
+  propertiesAndSettingsInHierarchyOf,
+  defaultInstanceInitializerMethod as defaultPropertyInstanceInitializerMethod
+}
+
 function hasManagedProperties(klass) {
   return klass.hasOwnProperty(defaultPropertiesKey);
 }
 
-export function prepareClassForManagedPropertiesAfterCreation(klass) {
+function prepareClassForManagedPropertiesAfterCreation(klass) {
   if (!hasManagedProperties(klass)) return;
 
   var {properties, propertySettings} = propertiesAndSettingsInHierarchyOf(klass);
@@ -94,25 +101,19 @@ function prepareClassForProperties(klass, propertySettings, properties) {
     var descriptor = properties[key];
 
     // ... define a getter to the property for the outside world...
-    var hasGetter = myProto.hasOwnProperty(key) && myProto.__lookupGetter__(key);
-    if (!hasGetter) {
-      var getter = descriptor.get
-                || (typeof defaultGetter === "function" && function() { return defaultGetter.call(this, key); })
-                || function() { return this[valueStoreProperty][key]; };
-      myProto.__defineGetter__(key, getter);
-    }
+    var getter = descriptor.get
+              || (typeof defaultGetter === "function" && function() { return defaultGetter.call(this, key); })
+              || function() { return this[valueStoreProperty][key]; };
+    myProto.__defineGetter__(key, getter);
 
     // ...define a setter if necessary
-    var hasSetter = myProto.hasOwnProperty(key) && myProto.__lookupSetter__(key);
-    if (!hasSetter) {
-      var descrHasSetter = descriptor.hasOwnProperty("set"),
-          setterNeeded = descrHasSetter || !descriptor.readOnly;
-      if (setterNeeded) {
-        var setter = descriptor.set
-                  || (typeof defaultSetter === "function" && function(val) { defaultSetter.call(this, key, val); })
-                  || function(val) { this[valueStoreProperty][key] = val; };
-        myProto.__defineSetter__(key, setter);
-      }
+    var descrHasSetter = descriptor.hasOwnProperty("set"),
+        setterNeeded = descrHasSetter || !descriptor.readOnly;
+    if (setterNeeded) {
+      var setter = descriptor.set
+                || (typeof defaultSetter === "function" && function(val) { defaultSetter.call(this, key, val); })
+                || function(val) { this[valueStoreProperty][key] = val; };
+      myProto.__defineSetter__(key, setter);
     }
 
   });
diff --git a/runtime.js b/runtime.js
index 7a85986..14ee090 100644
--- a/runtime.js
+++ b/runtime.js
@@ -1,5 +1,12 @@
 import { arr, obj } from "lively.lang";
-import { prepareClassForManagedPropertiesAfterCreation } from "./properties.js";
+import {
+  prepareClassForManagedPropertiesAfterCreation,
+  hasManagedProperties,
+  propertiesAndSettingsInHierarchyOf,
+  defaultPropertyInstanceInitializerMethod
+} from "./properties.js";
+
+
 
 export const initializeSymbol       = Symbol.for("lively-instance-initialize"),
              instanceRestorerSymbol = Symbol.for("lively-instance-restorer"),
@@ -72,18 +79,18 @@ function installGetterSetterDescriptor(klass, descr) {
 function installMethods(klass, instanceMethods, classMethods) {
   // install methods from two lists (static + instance) of {key, value} or
   // {key, get/set} descriptors
-
-  classMethods && classMethods.forEach(ea => {
+  classMethods && classMethods.forEach(ea =>
     ea.value ?
       installValueDescriptor(klass, klass, ea) :
-      installGetterSetterDescriptor(klass, ea);
-  });
+      installGetterSetterDescriptor(klass, ea));
 
-  instanceMethods && instanceMethods.forEach(ea => {
+  let props = hasManagedProperties(klass) ?
+        propertiesAndSettingsInHierarchyOf(klass) : null
+
+  instanceMethods && instanceMethods.forEach(ea =>
     ea.value ?
       installValueDescriptor(klass.prototype, klass, ea) :
-      installGetterSetterDescriptor(klass.prototype, ea);
-  });
+      installGetterSetterDescriptor(klass.prototype, ea));
 
   // 4. define initializer method, in our class system the constructor is
   // generic and re-directs to the initializer method. This way we can change
@@ -108,19 +115,25 @@ function installMethods(klass, instanceMethods, classMethods) {
   }
 
   // 5. undefine properties that were removed form class definition
-  let instanceMethodsInClass = instanceMethods.map(m => m.key)
-                                  .concat(["constructor", "arguments", "caller"]),
-      instanceAttributes = Object.getOwnPropertyNames(klass.prototype);
-  for (let i = 0; i < instanceAttributes.length; i++) {
-    let name = instanceAttributes[i];
-    if (!instanceMethodsInClass.includes(name)) delete klass.prototype[name];
+  let existingInstanceMethods = {
+    "constructor": true, "arguments": true, "caller": true,
+    [defaultPropertyInstanceInitializerMethod]: true
   }
+  instanceMethods.forEach(m => existingInstanceMethods[m.key] = true);
+  if (props) Object.assign(existingInstanceMethods, props.properties);
+  let instanceAttributes = Object.getOwnPropertyNames(klass.prototype);
 
-  let classMethodsInClass = classMethods.map(m => m.key)
+  for (var i = 0; i < instanceAttributes.length; i++) {
+    var name = instanceAttributes[i];
+    if (!existingInstanceMethods.hasOwnProperty(name))
+      delete klass.prototype[name];
+  }
+
+  var classMethodsInClass = classMethods.map(m => m.key)
                               .concat(["length", "name", "prototype", "arguments", "caller"]),
       classAttributes = Object.getOwnPropertyNames(klass);
-  for (let i = 0; i < classAttributes.length; i++) {
-    let name = classAttributes[i];
+  for (var i = 0; i < classAttributes.length; i++) {
+    var name = classAttributes[i];
     if (!classMethodsInClass.includes(name)) delete klass[name];
   }
 }
